

/* 
 *    Data Access Object that uses GSON library (from Google) for 
 *    converting objects to/from json representation.
 *    GSON performance on small datasets is good (https://blog.takipi.com/the-ultimate-json-library-json-simple-vs-gson-vs-jackson-vs-json/) 
 */
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.stream.JsonReader;

import java.io.*;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class JsonDao2<IDType, T extends Serializable> implements GenericCustSetDAO<IDType, T>, GenericItemsSetDAO<IDType, T> {

	// collection class to read entities in & out of persistent storage
	private Map<IDType, T> entityMap2 = new HashMap<>();
	// filename associated with the ObjectStream
	private final String fileName2;
	private final Type type2;

	/**
	 * Constructor to create new JsonDao
	 *
	 * @param fileName
	 *            name of the file to be written to, filename is written to
	 *            project's current directory
	 * @param type
	 *            Type of entity that is stored in the Dao, unfortunately Gson
	 *            cannot unmarshall generics back into the correct type without this
	 *            field
	 */
	public JsonDao2(String fileName2, Type type2) {
		this.fileName2 = fileName2;
		this.type2 = type2;
		readFileIntoMap();
	}

	/**
	 * Add an entity to the JsonDao
	 *
	 * @param id
	 *            id of the entity to be added with Type IDType
	 * @param entity
	 *            object of Type T to be added to the collection
	 */
	@Override
	public void add(IDType id, T entity) {
		readFileIntoMap();
		entityMap2.put(id, entity);
		writeMapToFile();
	}

	/**
	 * Update an entity to the JsonDao
	 *
	 * @param id
	 *            id of the entity to be update with Type IDType
	 * @param entity
	 *            object of Type T to be updated to the collection
	 */
	@Override
	public void update(IDType id, T entity) {
		readFileIntoMap();
		entityMap2.put(id, entity);
		writeMapToFile();
	}

	/**
	 * Remove an entity to the JsonDao
	 *
	 * @param id
	 *            id of the entity to be removed with Type IDType
	 */
	@Override
	public void remove(IDType id) {
		readFileIntoMap();
		entityMap2.remove(id);
		writeMapToFile();
	}

	/**
	 * Find an entity in the JsonDao
	 *
	 * @param key
	 *            id of the entity to find
	 */
	@Override
	public T find(IDType key) {
		readFileIntoMap();
		return entityMap2.get(key);
	}

	/**
	 * List all entities in the persisted collection
	 *
	 * @return List of all entity objects of Type T in the collection
	 */
	@Override
	public List<T> list() {
		readFileIntoMap();
		return new ArrayList<>(entityMap2.values());
	}

	/**
	 * Calculates the number of Objects currently in the Object Stream
	 * 
	 * @return number of Objects currently in the Object Stream persistent storage
	 */
	public int determineNumberOfObjectsInStream() {
		Map<IDType, T> tempEntityMap = new HashMap<>();
		Gson gson = new Gson();
		try {
			JsonReader jsonReader = new JsonReader(new FileReader(new File(fileName2)));
			tempEntityMap = gson.fromJson(jsonReader, type2);
			if (tempEntityMap == null) {
				tempEntityMap = new HashMap<>();
			}
		} catch (FileNotFoundException e) {
			tempEntityMap = new HashMap<>();
		}
		return tempEntityMap.size();
	}

	private void readFileIntoMap() {
		Gson gson = new Gson();
		try {
			JsonReader jsonReader = new JsonReader(new FileReader(new File(fileName2)));
			entityMap2 = gson.fromJson(jsonReader, type2);
			if (entityMap2 == null) {
				entityMap2 = new HashMap<>();
			}
		} catch (FileNotFoundException e) {
			entityMap2 = new HashMap<>();
		}
	}

	private void writeMapToFile() {
		try {
			Gson gson2 = new GsonBuilder().setPrettyPrinting().create();
			String jsonOutput2 = gson2.toJson(entityMap2);
			BufferedOutputStream bufferedOutputStream2 = new BufferedOutputStream(new FileOutputStream(fileName2));
			bufferedOutputStream2.write(jsonOutput2.getBytes());
			bufferedOutputStream2.close();
		} catch (IOException e) {
			System.out.println("An error occurred writing back to file.");
		}
	}
}